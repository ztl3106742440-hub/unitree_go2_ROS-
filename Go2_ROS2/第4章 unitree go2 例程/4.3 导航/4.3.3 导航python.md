colcon build --packages-select go2_tutorial_py
. install/setup.bash
ros2 launch go2_tutorial_py go2_nav.launch.py

另一个终端
. install/setup.bash
ros2 run go2_tutorial_py go2_nav_client 1.0




colcon build --packages-select go2_tutorial_inter
. install/setup.bash




1. go2_tutorial_py/go2_tutorial_py 下创建 go2_nav_server.py
```
"""

导航服务端

需求：

1.处理客户端需求

提交的请求为浮点数（前进距离）

如果大于0,则前进；否则认为不合法

2.处理客户端取消请求

当客户端发送取消请求，则让机器人停止

3.产生连续反馈和最终响应

根据机器人当前坐标，结合起点坐标与前进距离，计算剩余距离并周期性反馈

当机器人到达目标点，响应机器人坐标

实现：

1.创建action服务器，执行相关操作；

2.向 go2_ctrl 注入参数控制机器人运动或停止；

3.订阅机器人里程计获取坐标。

  

"""

import rclpy

from rclpy.node import Node

from rclpy.action import ActionServer

from go2_tutorial_inter.action import Nav

from geometry_msgs.msg import Point

from nav_msgs.msg import Odometry

from .sport_model import ROBOT_SPORT_API_IDS

from unitree_api.msg import Request

import json

from rclpy.action.server import CancelResponse,GoalResponse,ServerGoalHandle

import time

import math

from rclpy.executors import MultiThreadedExecutor

  

class Go2NavServer(Node):

def __init__(self):

super().__init__('go2_nav_server')

  

# 创建空point

self.point = Point()

# 订阅里程计数据

self.odom_sub = self.create_subscription(Odometry,"odom",self.odom_cb,10)

# 设置巡航参数

self.declare_parameter("x",0.3)

# 创建速度控制的发布对象

self.api_id = ROBOT_SPORT_API_IDS["BALANCESTAND"]

self.req_pub = self.create_publisher(Request,"/api/sport/request",10)

self.timer = self.create_timer(0.1,self.on_timer)

  

# 创建 actionserver

self.action_server = ActionServer(

self,

Nav,

"nav",

self.execute, # 主逻辑的处理函数

goal_callback = self.goal_cb,

cancel_callback = self.cancel_cb

)

def execute(self,goal_handle : ServerGoalHandle):

  

feedback = Nav.Feedback()

# 生成连续反馈

while rclpy.ok():

# 休眠

time.sleep(0.5)

# 组织数据

# 剩余距离

# 计算当前点 与 起点的距离差， 剩余距离 = 前进距离- 距离差

dis_x = self.point.x - self.start_point.x

dis_y = self.point.y - self.start_point.y

dis = math.sqrt(math.pow(dis_x,2) + math.pow(dis_y,2))

distance = goal_handle.request.goal - dis

feedback.distance = distance

# 发布

goal_handle.publish_feedback(feedback)

# 退出

if distance < 0.2:

self.api_id = ROBOT_SPORT_API_IDS["STOPMOVE"]

break

  

# 响应最终结果

goal_handle.succeed()

result = Nav.Result()

result.point = self.point

return result

  

return Nav.Result()

  

# 目标处理

def goal_cb(self,goal_request: Nav.Goal):

if goal_request.goal > 0.0:

self.start_point = self.point

self.get_logger().error("提交的数据合法，机器人开始运动")

self.api_id = ROBOT_SPORT_API_IDS["MOVE"]

return GoalResponse.ACCEPT

else:

self.get_logger().error("提交的数据非法")

self.api_id = ROBOT_SPORT_API_IDS["STOPMOVE"]

return GoalResponse.REJECT

  

# 无条件取消

def cancel_cb(self,cancle_request):

self.api_id = ROBOT_SPORT_API_IDS["STOPMOVE"]

return CancelResponse.ACCEPT

  

# 里程计回调函数

def odom_cb(self, odom : Odometry):

self.point = odom.pose.pose.position

  

def on_timer(self):

req = Request()

# 设置数据

# self.get_logger().info("api_id = %d" % self.api_id)

req.header.identity.api_id = self.api_id

# 设置参数

js = {

"x": self.get_parameter("x").value,

"y": 0.0,

"z": 0.0,

}

req.parameter = json.dumps(js)

self.req_pub.publish(req)

  

def main():

rclpy.init()

# rclpy.spin(Go2NavServer())

# 使用多线程执行器运行节点

node = Go2NavServer()

# 创建多线程执行器

executor = MultiThreadedExecutor()

# 把节点添加到执行器

executor.add_node(node)

# 调用执行器的 spin

executor.spin()

  

rclpy.shutdown()

  

if __name__ == '__main__':

main()
```


2. go2_tutorial_py/go2_tutorial_py 下创建 go2_nav_client.py
```
"""

导航客户端

需求：

客户端发送数据到服务端，并发送服务端的响应结果

流程：

1.判断程序执行时参数个数是否合法；

2.初始化 ROS2；

3.创建action客户端对象；

4.连接服务器；

5.发送请求数据并处理响应结果。若连接失败，直接退出。

6.调用 spin 函数，并传入节点对象指针；

7.释放资源。

"""

import rclpy

from rclpy.node import Node

import sys

from rclpy.logging import get_logger

from rclpy.action import ActionClient

from go2_tutorial_inter.action import Nav

  

class Go2NavClient(Node):

def __init__(self):

super().__init__('go2_nav_client')

self.client = ActionClient(self,Nav,"nav")

self.done = False

  

def connect_server(self):

while not self.client.wait_for_server(1.0):

self.get_logger().info("服务连接中...")

if not rclpy.ok():

return False

return True

def send_goal(self,goal):

# 组织数据

goal_msg = Nav.Goal()

goal_msg.goal = goal

# 发送数据，并处理响应

future : rclpy.task.Future = self.client.send_goal_async(goal_msg,self.feedback_callback)

future.add_done_callback(self.goal_response)

  

def goal_response(self,future: rclpy.task.Future):

goal_handle : rclpy.action.client.ClientGoalHandle = future.result()

# self.get_logger(),info("%s" % goal_handle.__str__()) ClientGoalHandle

if goal_handle.accepted:

self.get_logger().info("目标请求被接收")

future : rclpy.task.Future = goal_handle.get_result_async()

future.add_done_callback(self.result_response)

else:

self.get_logger().info("目标请求被拒绝")

# rclpy.shutdown()

self.done = True # 标记完成

self._done = True

  

def result_response(self,future: rclpy.task.Future):

result : Nav.Result = future.result().result

self.get_logger().info("机器人到达后坐标：(%.2f,%.2f)" % (result.point.x, result.point.y))

self.done = True # 标记完成

self._done = True

  

def feedback_callback(self,fb_msg):

# 处理连续反馈

fb : Nav.Feedback = fb_msg.feedback

self.get_logger().info("距离目标还有 %.2f 米" % fb.distance)

  

def main():

# 判断程序执行时参数个数是否合法；

if len(sys.argv) != 2:

get_logger("rclpy").error("请提交一个浮点类型的参数！")

return

# 初始化 ROS2

rclpy.init()

# 创建cation客户端对象

go2_nav_client = Go2NavClient()

# 连接服务端

flag = go2_nav_client.connect_server()

# 连接成功后，发送请求数据，并处理响应结果。连接失败，直接退出。

if not flag:

get_logger("rclpr").error("服务器连接失败")

rclpy.shutdown()

return

get_logger("rclpr").info("连接成功，发送请求！")

  

# 发送请求

go2_nav_client.send_goal(float(sys.argv[1]))

  

# ⭐ 关键：可控 spin，而不是 rclpy.spin()

while rclpy.ok() and not go2_nav_client.done:

rclpy.spin_once(go2_nav_client, timeout_sec=0.1)

  

# 清理资源

go2_nav_client.destroy_node()

  

# rclpy.spin(go2_nav_client)

rclpy.shutdown()

  

if __name__ == '__main__':

main()
```



3. setuo.py :
```
go2_nav_client = go2_tutorial_py.go2_nav_client:main,
go2_nav_server = go2_tutorial_py.go2_nav_server:main,
```

4. launch 下创建 go2_nav.launch.py
复制go2_cruising.launch.py 更改：
```
cru_nav_node = Node(
package="go2_tutorial_py",
executable="go2_nav_server",
# parameters=[os.path.join(go2_tutorial_pkg,"params","go2_cruising_service.yaml")]
)

return LaunchDescription([
go2_driver_launch,
# go2_ctrl_launch,
cru_nav_node,
])
```
